# React  template

Этот проект был создан при помощи
[Create React App](https://github.com/facebook/create-react-app). Для знакомства
и настройки дополнительных возможностей
[обратись к документации](https://facebook.github.io/create-react-app/docs/getting-started).

## Создание репозитория по шаблону

Используй этот репозиторий организации GoIT как шаблон для создания репозитория
своего проекта. Для этого нажми на кнопку `«Use this template»` и выбери опцию
`«Create a new repository»`, как показано на изображении.

![Creating repo from a template step 1](./assets/template-step-1.png)

На следующем шаге откроется страница создания нового репозитория. Заполни поле
его имени, убедись что репозиторий публичный, после чего нажми кнопку
`«Create repository from template»`.

![Creating repo from a template step 2](./assets/template-step-2.png)

После того как репозиторий будет создан, необходимо перейти в настройки
созданного репозитория на вкладку `Settings` > `Actions` > `General` как
показано на изображении.

![Settings GitHub Actions permissions step 1](./assets/gh-actions-perm-1.png)

Проскролив страницу до самого конца, в секции `«Workflow permissions»` выбери
опцию `«Read and write permissions»` и поставь галочку в чекбоксе. Это
необходимо для автоматизации процесса деплоя проекта.

![Settings GitHub Actions permissions step 2](./assets/gh-actions-perm-2.png)

Теперь у тебя есть личный репозиторий проекта, со структурой файлов и папок
репозитория-шаблона. Далее работай с ним как с любым другим личным репозиторием,
клонируй его себе на компьютер, пиши код, делай коммиты и отправляй их на
GitHub.

## Подготовка к работе

1. Убедись что на компьютере установлена LTS-версия Node.js.
   [Скачай и установи](https://nodejs.org/en/) её если необходимо.
2. Установи базовые зависимости проекта командой `npm install`.
3. Запусти режим разработки, выполнив команду `npm start`.
4. Перейди в браузере по адресу [http://localhost:3000](http://localhost:3000).
   Эта страница будет автоматически перезагружаться после сохранения изменений в
   файлах проекта.

## Деплой

Продакшн версия проекта будет автоматически проходить линтинг, собираться и
деплоиться на GitHub Pages, в ветку `gh-pages`, каждый раз когда обновляется
ветка `main`. Например, после прямого пуша или принятого пул-реквеста. Для этого
необходимо в файле `package.json` отредактировать поле `homepage`, заменив
`your_username` и `your_repo_name` на свои, и отправить изменения на GitHub.

```json
"homepage": "https://your_username.github.io/your_repo_name/"
```

Далее необходимо зайти в настройки GitHub-репозитория (`Settings` > `Pages`) и
выставить раздачу продакшн версии файлов из папки `/root` ветки `gh-pages`, если
это небыло сделано автоматически.

![GitHub Pages settings](./assets/repo-settings.png)

### Статус деплоя

Статус деплоя крайнего коммита отображается иконкой возле его идентификатора.

- **Желтый цвет** - выполняется сборка и деплой проекта.
- **Зеленый цвет** - деплой завершился успешно.
- **Красный цвет** - во время линтинга, сборки или деплоя произошла ошибка.

Более детальную информацию о статусе можно посмотреть кликнув по иконке, и в
выпадающем окне перейти по ссылке `Details`.

![Deployment status](./assets/deploy-status.png)

### Живая страница

Через какое-то время, обычно пару минут, живую страницу можно будет посмотреть
по адресу указанному в отредактированном свойстве `homepage`. Например, вот
ссылка на живую версию для этого репозитория
[https://goitacademy.github.io/react-homework-template](https://goitacademy.github.io/react-homework-template).

Если открывается пустая страница, убедись что во вкладке `Console` нет ошибок
связанных с неправильными путями к CSS и JS файлам проекта (**404**). Скорее
всего у тебя неправильное значение свойства `homepage` в файле `package.json`.

### Маршрутизация

Если приложение использует библиотеку `react-router-dom` для маршрутизации,
необходимо дополнительно настроить компонент `<BrowserRouter>`, передав в пропе
`basename` точное название твоего репозитория. Слеш в начале строки обязателен.

```jsx
<BrowserRouter basename="/your_repo_name">
  <App />
</BrowserRouter>
```

## Как это работает

![How it works](./assets/how-it-works.png)

1. После каждого пуша в ветку `main` GitHub-репозитория, запускается специальный
   скрипт (GitHub Action) из файла `.github/workflows/deploy.yml`.
2. Все файлы репозитория копируются на сервер, где проект инициализируется и
   проходит линтинг и сборку перед деплоем.
3. Если все шаги прошли успешно, собранная продакшн версия файлов проекта
   отправляется в ветку `gh-pages`. В противном случае, в логе выполнения
   скрипта будет указано в чем проблема.


project development step by step

1. подключаю готовый React  template по инструкции выше.
2. Делаю все настройки по инструкции.
3. создаю файл GlobalStyle.js. Переношу все общие настройки из файла index.css в файл GlobalStyle.js.
4. Делаю импорт GlobalStyle.js в index.js. И вставляю компонет <GlobalStyle/>.
5. Делаю папку UI. В этой папке будут находиться общие для всего проекта файлы и styled components.Переношу
   GlobalStyle.js в common.
6. Создаю папку Header. В ней Header.jsx и Header.styled.js.
7. Создаю папку pages. В ней НomePages и LibraryPages.
8. Устанавливаю следующие пакеты npm:
 "@reduxjs/toolkit": "^1.9.2",
    "axios": "^1.3.2",
    "firebase": "^9.17.1",
    "modern-normalize": "^1.1.0",
    "react-hot-toast": "^2.4.0",
    "react-icons": "^4.7.1",
    "react-redux": "^8.0.5",
    "react-router-dom": "^6.8.1",
    "styled-components": "^5.3.6",
9.Если приложение использует библиотеку `react-router-dom` для маршрутизации,
  необходимо дополнительно настроить компонент `<BrowserRouter>`, передав в пропе
 `basename` точное название твоего репозитория. Слеш в начале строки обязателен.
  <BrowserRouter basename="/your_repo_name">
  <App />
  </BrowserRouter>
  У меня /my-filmoteka -- /your_repo_name
10. Делаю маршрутизацию:
   а. делаю import { Routes, Route } from "react-router-dom" в App.jsx
   b. Прописываю маршруты для HomePage  и LibraryPage:
      export const App = () => {
  return (
    <div>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<LibraryPage />} />
      </Routes>
    </div>
  );
  };
 Группу маршрутов обязательно должен оборачивать компонент Routes, даже если маршрут всего один. То есть Route не может использоваться вне Routes. Этот компонент выполняет логику подбора наиболее подходящего Route для текущего значения URL в адресной строке браузера.
11. Что будет если пользователь перейдет по ссылке /non-existing-route или любой другой, которой не существует в нашем   приложении? Он увидит пустую вкладку браузера, без какого либо контента, так как ни один из описанных нами Route не  подойдет. Для этого в самый конец списка маршрутов добавим еще один Route, который будет совпадать с любым URL, но он будет выбран только в том случае, если ни один другой маршрут не подойдет.
Для этого создаём в pages страницу NotFound.jsx.
12. Создаём маршрут для NotFound
     const App = () => {
  return (
    <div>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<LibraryPage />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </div>
  );
};
Символ * в пропсе path буквально указывает на то, что этот маршрут может совпадать с любым значеним URL. Поэтому если ни один предыдущий Route не подойдет, последний уж точно отобразит пользователю страницу с каким-то сообщением о том, что маршрута по которому он перешел не существует.
13. Теперь создаём ссылки на различные страницы нашего приложения.
    Для создания навигации нельзя использовать обычный тег <a href="/about">. При клике, вместо того чтобы изменить URL на текущей странице, и позволить маршрутизатору выполнить навигацию на стороне клиента, браузер перезагрузит страницу.

   Для создания ссылок используются компоненты Link и NavLink. Они рендерят тег <a>, но стандартное поведение ссылки изменено так, что при клике просто обновляется URL в адресной строке браузера, без перезагрузки страницы.

 
14. Компонент NavLink отличается только тем, что может иметь дополнительные стили, если текущий URL совпадает со значением пропcа to. По умолчанию элементу активной ссылки добавляется класс active. Это можно использовать для её стилизации.
Стилизуем  Link и подключаем в APP.js. Для этого создаём папку Link в UI 
для этого импортируем import { NavLink } from 'react-router-dom'  в Link.styled.js и создаём компонент Link.
15. Вставляем блок:
 <nav>
        <LinkStyled to="/" end>
          Home
        </LinkStyled>
        <LinkStyled to="/library">Library</LinkStyled>
      </nav>
  в APP
16. Создаём компонент Header  и стилизуем его. Подключаем его в APP. И в Header всатвляем блок <nav></nav>
17. Сделаем ещё одну страницу Movies (на ней будем отображать фильмы по поиску). И подключим
     <Route path="/about" element={<MoviesPage  />} /> в АРР. И <LinkStyled to="/movies">Movies</LinkStyled> в Header.
17. Создаём отдельную страницу для одного фильма  в pages.
    Немного теории: Динамические параметры похожи на параметры функции - у них всегда одно название, но могут быть разные значения. Они позволяют объявить шаблон адреса, части которого могут иметь произвольное значение. Например, не имеет смысла определять отдельный маршрут для каждого фильма на сайте, их могут быть тысячи. По структуре контента такие страницы будут идентичны, а отличаться будет только название, изображение, автор, текст и т. п. Вместо того чтобы определять маршрут для каждого фильма, мы можем объявить один маршрут с динамическим параметром по которому будем определять какой фильм необходимо отображать именно сейчас. Для того чтобы указать, что какая-то часть адреса это URL-параметр, используется двоеточие (:) перед именем параметра.
      <Route path="/movies/:movieId" element={<SingleMoviePage />} />
      Каждый раз, когда пользователь будет посещать адрес соответствующий шаблону /movies/:movieId, например /movies/batman или /movies/avatar, ему будет отображаться страница этого фильма.
      Добавим в наше приложение маршрут страницы одного фильма c адресом /movies/:movieId. Это отдельная страница, никак не привязанная к /movies - странице отображения всех movies.
18. Создадим Хук useParams в  SingleMoviePage.
    Он Возвращает объект со всеми динамическими параметрами которые есть в текущем URL. Имя параметра будет именем свойства в объекте, а его текущее значение в адресе - значением свойства. Например, если объявлен следующий маршрут /movies/:genreId/:movieName, и пользователь находится по адресу /movies/adventure/avatar. 
    const { genreId, movieName} = useParams();
    console.log(genreId, movieName); // adventure, avatar
    Для того чтобы получить значение динамической части URL, в нашем случае идентификатор movie, используем хук useParams в компоненте страницы SingleMoviePage.   
      import { useParams } from "react-router-dom";

    const SingleMoviePage = () => {
    const { movieId } = useParams();
    return <div>Now showing movie with id - {movieId}</div>;
};
19. TODO!!!! Надо будет сделать вложенные маршруты!!!!!!!!!!!!!
20. Сделаем стрницу about. Пока как пример.
21. Делаем индексные маршруты.
     Приём «shared layout», который заключается в том, что какая-то общая HTML-разметка и стили всего или части страниц приложения выносятся в отдельный компонент, вместо того чтобы дублироваться на каждой странице. В нашем приложении filmoteka это хедер с логотипом и главной навигацией, а также контейнер ограничивающий ширину контента страниц.
     Вынесем  разметку и её стили в отдельный компонент SharedLayout. Обращаем внимание на использование и местоположение Outlet - в это место будет рендерится разметка компонентов страниц.
     import { Outlet } from "react-router-dom";

export const Layout = () => {
  return (
    <Container>
      <Header/>
      <Outlet />
    </Container>
  );
};
Но у Header есть свой отдельный контейнер,т.к. будет background-image растянутый на всю страницу.
     <>
      <Header/> 
     <Container>
      <Outlet />
    </Container>
    </>
 Далее используем этот компонент в App так чтобы он рендерился на любой маршрут. Для этого будем рендерить его на /, а все остальные маршруты делаем вложенными в него, поэтому изменим path всех вложенных маршрутов относительно родительского.
  Может возникнуть вопрос куда пропал компонент Home который ранее рендерился на path="/". Проблема в том, что сейчас на /about рендерится SharedLayout и About, а на / только SharedLayout. Для того чтобы отрендерить компонент Home на тот же маршрут на который рендерится его родитель, необходимо сделать «индексный маршрут». Индексным может быть только вложенный маршрут. В его Route не указывается пропс path, потому что он совпадает со значением path родителя. Вместо этого передается специальный пропс index, который указывает React Router что маршрут индексный и должен быть отрендерен на тот же адрес что и его родитель.  Индексным может быть только вложенный маршрут. В его Route не указывается пропс path, потому что он совпадает со значением path родителя. Вместо этого передается специальный пропс index, который указывает React Router что маршрут индексный и должен быть отрендерен на тот же адрес что и его родитель.
22. Делаем разделение кода.
    По умолчанию все зависимости проекта объединяются в один файл. Чем больше кода, тем медленнее он будет загружаться, парситься и исполняться в браузере пользователя. На слабых компьютерах или телефонах, с плохим подключением к Интернет, это могут быть десятки секунд.

При разработке на локальном сервере (localhost) все файлы раздаются с нашего компьютера. В этом случае скорость подключения к Интернету не имеет значения, и поэтому файлы проекта загружаются очень быстро. Однако в продакшене загрузка больших файлов может стать проблемой, потому что не везде есть высокоскоростной Интернет и мощные компьютеры.

Решение проблемы очевидно - разбить проект на более мелкие файлы и загружать их только по необходимости. В этом и заключается концепция разделения кода. Если пользователь заходит на страницу логина, не нужно загружать весь код приложения, будет достаточно части отвечающей за рендер компонентов только этой страницы. Разделение кода на несколько файлов это задача сборщика проекта, например Webpack, а не фронтенд фреймворка. Create React App внутренне использует Webpack как сборщик и поддерживает разделение кода без дополнительной настройки.Код приложения необходимо разделять по маршрутам и загружать по необходимости. Этого достаточно для большинства приложений. Переходим на новую страницу - загружается необходимый код для отображения её компонентов. Такой подход называется разделение кода на основе маршрутов (route-centric).Разработчик принимает решение как, что и где разделять. Тем не менее вот несколько лучших практик.

Разделение кода на основе маршрутов обязательно в любом приложении.
Разделение кода на основе компонентов стоит делать только в больших, сложных интерфейсах с сотнями компонентов и большими библиотеками.
Чрезмерное разделение кода тоже не лучшая идея. HTTP-запрос за файлом может быть дольше чем добавленный вес к первой загрузке.
React предоставляет API для того, чтобы указать какой код необходимо выделить в отдельный файл, а потом загружать и рендерить только при необходимости. Функция React.lazy() отвечает за асинхронную загрузку компонента, а Suspense приостанавливает его отображение до завершения загрузки.
С разделением кода
import { lazy, Suspense } from "react";

const MyComponent = lazy(() => import("path/to/MyComponent"));

const App = () => {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/some-path" element={<MyComponent />} />
        {/* Другие маршруты */}
      </Routes>
    </Suspense>
  );
};
Метод lazy() ожидает функцию-згарузчик, которая возвращает результат динамического импорта - промис, значением которого будет дефолтный экспорт модуля (компонент). Если во время рендера компонент MyComponent еще не загружен, необходимо показать заглушку. Для этого используется компонент Suspense. Проп fallback принимает любой React-элемент или компонент. Suspense можно поместить в любом месте над асинхронным компонентом или группой компонентов.Обратите внимание на отсутствие статического импорта MyComponent в последнем примере. Вместо этого используется функция import(). Если оставить статический импорт, то Webpack не выполнить разделение кода и добавит весь код MyComponent в основной JavaScript файл проекта.Если вы используете прием «shared layout», то нужно разместить Suspense непосредственно внутри компонента SharedLayout. В противном случае, при загрузке каждой страницы, будут пропадать и повторно рендериться компоненты общей части страниц, например хедер и навигация.
На основе всего этого в АРР меняем импорт страница на:
 const MyComponent = lazy(() => import("path/to/MyComponent"));
 Старые импорты я комменчу.
 23. Для приема «shared layout», то нужно разместить Suspense непосредственно внутри компонента SharedLayout. В противном случае, при загрузке каждой страницы, будут пропадать и повторно рендериться компоненты общей части страниц, например хедер и навигация. Поэтому:
 import { Suspense } from "react";
import { Outlet } from "react-router-dom";

const Layout = () => {
  return (
    <Container>
      <AppBar>
        <Navigation />
        <UserMenu />
      </AppBar>

      <Suspense fallback={<div>Loading...</div>}>
        <Outlet />
      </Suspense>
    </Container>
  );
};

24. TODO!!!!!!!!!!!!!!!!!! для вложенных маршрутов надо будет поставить также Suspense.
25. ДЕЛАЕМ РЕГИСТРАЦИЮ НОВОГО ПОЛЬЗОВАТЕЛЯ И ЕГО ПРОВЕРКУ. ДЕЛАЕМ С ПОМОЩЬЮ REDUX, REDUX\TOOLKIT И FIREBASE.
26. Cоздаём компоненты  в UI Form Input Buttuon
27. в FORM делаю инпут для е-майл, инпут для пароля, кнопку Submit. Импортирую useState из react. Делаю два useState:
const [email, setEmail] = useState("")  и const [password, setPassword]= useState(""). В Input для е-майл: type="email",
value="email", OnChange ={(e) => setEmail(e.target.value)}. Для Input тоже самое только со словом pasword. На кнопку вешаем событие onClick={() => handleClick(email, password)}.
28. Делаю AuthNav где линки LogIn и Register.
29. Вставляем их в Header. И делаем стилизацию  Header: Делаем компонент Navigation:Home,About, Movies, Library.
30 Делаем модальное окно и делаем так чтоБы при нажатии ссылок AuthNav открывалось модальное окно, а не переходило на новую страницу.
31.Делаем компоненты LogIn и Register.
32. Делаем LoginModal и  RegisterModal.Пока не делаем!!!!!!!!!!!!
33. Делаю LoginPage и RegisterPage и компоненты Login и SignUp.
34. Добавляю LoginPage и RegisterPage в АРР.
35. Настраиваем Redux: создаём папку Redux в ней делаем файлы store.js и userSlice.js.
36.   В файле userSlice.js импортируем {createSlice} from '@reduxjs/toolkit'; Создаём начальное состояние state:
     const initialState = {
    email: null,
    token: null,
    id: null,
    };
37.  Потом создайём userSlice:
     const userSlice = createSlice({
    name: 'user',
    initialState,
    reducers: {
        setUser(state, action) {
            state.email = action.payload.email;
            state.token = action.payload.token;
            state.id = action.payload.id;
        },
        removeUser(state) {
            state.email = null;
            state.token = null;
            state.id = null;
        },
    },
});
38. И делаем экспорт: 
export const {setUser, removeUser} = userSlice.actions;

export default userSlice.reducer;
39. Создаём store.js:
   import {configureStore} from '@reduxjs/toolkit';
   import userReducer from './slices/userSlice';

   export const store = configureStore({
    reducer: {
        user: userReducer,
    }
  }); 

  40. В index.js имрпортируем Provider из  react-redux, импортируем store из store.js.
   Оборачиваем в Provider АРР: 
      <Provider store={store}>
        <App />
      </Provider>
  41. Делаем папку hooks. В ней создаём хук use-auth, котрый позволяет в любой точке приложения  узнавать авторизован пользователб или нет.
 42. Привязывеам авторизацию к Firebase.
 Заходим на сайт: https://firebase.google.com/
 43. Добавляем проект + add Project вводим название проекта. Убираем гугл-аналитику. Выбираем вариант подключения WEB. Задаём название своего приложения. Устанавливаем пакает npm firebase.Делаем инициализацию нашего приложения и в эту инициализацию набросать конфиг, для этого создаём файл firebase.js. В него добавляем:

import { initializeApp } from "firebase/app"

  const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID
  };

const app = initializeApp(firebaseConfig);

 44. В корне проекта создаем файл: .env.local И туда вносим секретный кода, которые дал firebase
 45. Делаем import './firbase' в index.js 
 46. В документации firbase есть логика для существующих пользователей и для новыч пользователей. 
 Поэтому для новых пользователей в SignUp делаем:
   const handleRegister = (email, password) => {
        const auth = getAuth();
        createUserWithEmailAndPassword(auth, email, password)
            .then(({user}) => {
                console.log(user);
                dispatch(setUser({
                    email: user.email,
                    id: user.uid,
                    token: user.accessToken,
                }));
                push('/');
            })
            .catch(console.error)
